> 链接：https://mp.weixin.qq.com/s/LIeb5DwMS6RS2YhEw47GDA

> 理解 TCP 实现的部分细节

每个人，对于 TCP 协议可以说是熟悉的，也可以说是不熟悉的。
熟悉，是因为它的三次握手、四次挥手、滑动窗口、慢启动、拥塞避免、拥塞控制等概念好像都有些了解。说不熟悉，是因为它很复杂，在运行过程中网络环境会变化，TCP 的相关机制也会产生相关的适应行为。

## TCP 是一个面向连接可靠的传输层协议，但什么是面向连接可靠呢？
TCP 协议复杂的原因，就是因为 IP 协议的交付质量，IP 是面向无连接不可靠的协议，TCP 需要基于它去设计一个面向连接可靠的传输层协议
## 什么是面向连接？
发送方关心接收方是否处于可接收数据的状态，并且关心传输时，数据之间的关系。
## 什么是可靠？
数据在传输过程中不会被损坏或者丢失，保证数据可以正确到达。
## 如何解决面向连接的问题？
通过建立连接，传输数据，断开连接的三步骤，创建一个长期的数据传输机制，在同一个连接中的数据传输有上下文关系。所以引申出了：
seq 序列号字段，维护传输数据的顺序关系，保证按序交付，同时，解决数据包重复的问题。
syn，ack，fin，rst 字段的值，创建、断开和维护一个连接。

```
- SYN：建立连接。在三次握手的第一步和第二步中使用。SYN 为 1 时，表示这是一个连接请求或连接接受请求
- ACK：确认收到的数据。TCP 规定，连接建立后，ACK 必须置为 1
- FIN：释放连接
- RST：重置连接
```

## 如何解决可靠性的问题？
引入数据确认机制，发送方发送数据后，等待对方确认。（停止等待协议）维护确认字段 Acknowledgement 和 ack 状态。
引入数据确认机制后，引发了带宽利用率不高的问题，解决方案：引入滑动窗口确认机制，即发送多个包之后，一起确认。
引入窗口后，如何在不同延时的网络上，确定窗口的大小？解决方案：引入窗口变量和窗口检测通告。

```
因为 TCP 协议是双向数据流，所以双方（发送方和接收方）都需要维护自己的发送窗口和接收窗口大小（左右边界），窗口大小的调整是一个动态过程，如下。
- 发送方根据网络状况和自身处理能力调整发送窗口
- 接收方根据自身处理能力调整接收窗口，并通过 ACK 通告给发送方
- 发送方根据接收方通告的窗口大小调整自己的发送窗口
这个过程持续进行且不是严格的轮流顺序。窗口的初始大小在三次握手时会协商好。
窗口检测通告，是为了让发送方检测到接收方的窗口何时再打开的定时器机制。例如，接收方缓冲区已满，会设置 ACK=0 并响应给发送方。发送方收到后，会启动一个持续计时器，每次倒计时结束，都会发送一个窗口探测数据包。
```

```
窗口检测通告机制，避免了死锁。场景如下。
- 接收方的窗口变为 0，通过 ACK 告诉发送方
- 过了一段时间，接收方的窗口不为 0 了，通知发送方，但是通知的数据包丢失了（接收方不会主动重传 ACK）
- 发送方一直等待窗口打开，接收方一直等待新数据
做完上面的事情后，带宽可以被充分利用了，但是网络环境是复杂的
```

做完上面的事情后，带宽可以被充分利用了，但是网络环境是复杂的，随时可能因为大量数据导致网络上的阻塞，这时候又需要引入阻塞控制等等。
TCP 复杂的原因，就是要在工程上解决这些问题。

## 为什么需要三次握手？
首先，需要理解建立连接的目的，如下。
1. 确定对端在线
2. 保证包的顺序（因为数据传输是双向的，所以两端都需要确认对端的起始序列号）

三次握手，才能满足第 2 个条件，假如两次握手，至少有一端无法确认对端是否了解你的起始序列号，即：我是服务端，对端发送起始序列号后，我也给对端回复我的起始序列号，此时，回复的数据包丢失，但我无法确认对端是否收到，所以还需要对端再确认一次。

假如，服务端 A 收到客户端 B 发的 SYN ，并回复了 SYN+ACK 后，又收到了另一个客户端 C 的请求，此时 A 会和 C 建立后续的 ESTABLISHED 连接吗？
当然不会，因为一个新的客户端 IP + Port 都不一样，直接发 ACK 后，TCP 会直接回复 RST，内核通过四元组进行校验，调用 __inet_lookup()进行查找。

```c++
static inline struct sock *__inet_lookup(...省略函数参数)
{
        u16 hnum = ntohs(dport);
        struct sock *sk;

        // 先检查 established 中是否有连接，如果没有就直接 send_reset
        sk = __inet_lookup_established(net, hashinfo, saddr, sport,
                                       daddr, hnum, dif, sdif);
        *refcounted = true;
        if (sk)
                return sk;
        *refcounted = false;
        // 再检查 linstener中 是否有连接，如果没有就直接 send_reset
        return __inet_lookup_listener(net, hashinfo, skb, doff, saddr,
                                      sport, daddr, hnum, dif, sdif);
}
```

通过代码中的注释，可以知道查找分为两步。
确认连接存在后，如果连接是 TCP_ESTABLISHED 状态，直接开始接收数据，否则开始处理 TCP 的各种状态，TCP 的不同状态如下。
- 第一次握手， TCP_LISTEN
- 第三次握手，TCP_SYN_RECV
服务端在 SYN RECVED 状态下，将在缓存中记录客户端 SYN 包中的内容，以便在收包的过程中查找。该内容占用的 SLAB 缓存。
SLAB 机制是 Linux 内核中的一种内存管理机制，用于管理小块内存的分配，通过对内核中经常使用的对象进行缓存和释放，SLAB可以有效减少分配小块连续内存时产生的内部碎片
TCP 包占用 SLAB 缓存是有上限的，上限值决定了 TCP 在正常状态下，可以维持多少个 TCP_SYN_RECVED 状态的连接，即半连接数，该值默认情况根据总内存大小自动生成，内存越大值越大。半连接以队列的形式存储。

## 半连接队列被耗尽怎么办？
回答这个问题需要先理解几个概念，如下。
- syncookie
- request_sock_queue 结构体中的 qlen
- TFO - TCP Fast Open
先抛出几个结论，当 syncookie 开启的情况，半连接队列可认为无上限。
request_sock_queue 结构体中的 qlen 会在 tcp_conn_request() 函数执行结束后增加，即 qlen 为服务器 listen 端口的半连接队列的当前长度。

```c++
if (!net->ipv4.sysctl_tcp_syncookies &&
                    (net->ipv4.sysctl_max_syn_backlog - inet_csk_reqsk_queue_len(sk) <
                     (net->ipv4.sysctl_max_syn_backlog >> 2)) &&
                    !tcp_peer_is_proven(req, dst)) {
```

当 sysctl_tcp_syncookies 未开启时，如果当前半连接池剩余长度，小于最大长度的四分之一后，就不再处理新建连接请求了，这也就是著名的 synflood 攻击的原理。
syncookie 的作用就是为了防止 synflood。

## syncookie 如何防止 synflood?
已明确 synflood 是针对半连接队列的攻击，那我们可以想办法绕过半连接池，能不能让服务端不记录第一次握手发过来的 SYN 四元组信息，同时还能在第三次握手的时候验证呢？其实是可能的，既然三次握手的第二次是服务端回包，那可以把第一次握手得到的消息放回包里，让客户端在第三次握手的时候再把这个信息带回来，然后我们拿到第三次握手的四元组信息后，再做验证。为了保证包内容尽量小，我们把数据放到包之前，做一下 hash 运算（根据四元组信息和当前时间），运算得到的结果就叫 cookie。